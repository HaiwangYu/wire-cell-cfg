#+TITLE: Wire Cell Toolkit Configuration

* Introduction

This repository holds support files for configuring Wire Cell Toolkit (WCT) configurable components and the main =wire-cell= command line application and the =WireCell::ConfigManager= component.

* Configuration from a user point of view

Many /component/ classes of the WCT accept a set of configuration parameters.  These /configurable/ components typically provide reasonable hard-coded defaults and the user may override a subset of parameters without recompiling by providing configuration information.  

It is up to the WCT application to accept this information and convert it into proper C++ object form (instances of =WireCell::Configuration=) and hand that to any instantiated components.  The user should refer to the documentation of their application on how to specify this information.  In the case of the provided =wire-cell= command line interface to the WCT and the =WireCell::ConfigManager= component that it uses that documentation is here.

** Configuration with =wire-cell= command line

Configuration is provided to =wire-cell= as one or more files (see [[Configuration file formats]] below).  

#+BEGIN_EXAMPLE
  $ wire-cell -c myparameters.cfg [...]
#+END_EXAMPLE

The user can also dump out a configuration file containing the hard-coded default parameters of one or more components.

#+BEGIN_EXAMPLE
  $ wire-cell \
      -p <plugin> \
      -D <component1> \
      -D <component2> \
      --dump-file=mydefaults.cfg
#+END_EXAMPLE

Here the components are specified by their "type name".  This is usually their C++ implementation class name with any namespace removed.  It's up to the component developer to communicate these names (see also the provided script [[./scripts/generate-defaults.sh]]).  One or more WCT plugins must also be specified so that =wire-cell= can locate the code and ask for the defaults.  A plugin usually takes the name of its shared library with the =lib= prefix and =.so= extension removed.  

** Configuration file formats

WCT accepts configuration information provided in two related file formats.

*** JSON

Examining a configuration dump shows the format is [[http://www.json.org/][JSON]].  For example,
#+BEGIN_EXAMPLE
  $ wire-cell -D TrackDepos -p WireCellGen
#+END_EXAMPLE
produces:
#+BEGIN_SRC js
  [
     {
        "data" : {
           "clight" : 1,
           "step_size" : 0.10000000000000001,
           "tracks" : []
        },
        "name" : "",
        "type" : "TrackDepos"
     }
  ]
#+END_SRC

In the WCT code the object schema for a configuration set is a list of objects.  This same schema is used for the JSON configuration file.  Three object keys are recognized:

- type :: identify the component "type name" associated with a C++ class that implements the component.  The *type* is typically, but need not be, the C++ class name with any C++ namespaces removed.  In this example =TrackDepos= names the =WireCell::Gen::TrackDepos= class.
- name :: specifies an /instance name/ which is used to differentiate between multiple instances of the *type*
- data :: the value of this key is a data structure following a schema specific to *type*

When a configuration is consumed, it instantiates components and configures them in the order given by this list.  This is important if one component requires another.  If general, configuration for a component must be placed *after* any others that it requires.

In this example, =TrackDepos= produces deposition (=IDepo=) objects using a simple linear source model.  The =tracks= array is empty by default and so would produce an empty set of depositions.  The user most certainly should specify a nonempty set of tracks.  This can be done by editing the JSON and feeding it back to =wire-cell= or writing a program to generate a complex set of tracks.  A third option exists as described next.

** Jsonnet

As the complexity of the =wire-cell= job grows, so will its configuration.  Simply adding more instances of components will require larger configuration files.  Some configuration information must be coordinated between multiple components.  Some configuration should be crafted by experts while still allowing novices to modify certain values.  A user is free to produce suitable JSON configuration in any desired manner.  However, WCT  provides support for a second format:  the [[http://jsonnet.org/][Jsonnet data templating language]] which provides many features to organize configuration information and which evaluates to JSON.  This support is a compile-time option which allows Jsonnet files to be read directly by =wire-cell=.  If a build of WCT lacks this support a user may build the Jsonnet package and run the =jsonnet= command line to produce JSON for use by their version of WCT.

To learn to write Jsonnet the user should refer to its documentation which is excellent.  There is no one right way to write Jsonnet, however, the [[https://github.com/wirecell/wire-cell-cfg][wire-cell-cfg]] package provides a number of examples and support files that can help the user.  In particular the WCT system of units and some common data structures used by WCT are exported to Jsonnet in [[./wirecell.jsonnet]].  Some of this exported functionality is illustrated below.  

To locate Jsonnet (or JSON) files the WCT makes use of an environment variable =WIRECELL_PATH=.  If using the =jsonnet= command line program the user may specify directories in which to search for files with =jsonnet -J <directory> [...]=.

*** System of units

Wire Cell provides an internal system of units. It's important to note that JSON configuration files must implicitly express quantities in the Wire Cell Toolkit system of units.  That is the user must know this system in order to write JSON.  When writing Jsonnet this is much easier as units can be stated explicitly such as in this example:

#+BEGIN_SRC js
  local wc = import "wirecell.jsonnet";
  [
      {
      type:"TrackDepos",
      data: {
          step_size: 1.0 * wc.millimeter,
          // or could abreviate with wc.mm
          }
      }
  ]
#+END_SRC

*** Functions

A number of functions are defined to assist in representing common data types. For example =point()= and =ray()=

#+BEGIN_EXAMPLE
  {
    // ...
    tracks : [ wc.ray(wc.point(10,0,0,wc.cm), wc.point(100,10,10,wc.cm)) ]
  },
#+END_EXAMPLE

*** Default Structures

Some common structures are defined with default objects so that they may be extended/overridden. For example, the =Node= object defines a default =type=, =name= and =port= to be used in a graph connection. It is typical to override at least the =type=:

#+BEGIN_EXAMPLE
  graph:[
  {
    tail: wc.Node {type:"TrackDepos"},
    head: wc.Node {type:"DumpDepos"}
  },
  //...
  ]
#+END_EXAMPLE

*** Commas

One of the most irritating aspect of crafting JSON files by hand is that any array or object must not have a internal trailing command.  Jsonnet allows this.  For this reason alone and if no other features are used, writing Jsonnet is worth the added dependency!

** Specific detector support

The =wire-cell-cfg= package also provides support for popular LArTPC detectors.  You can find these files under a directory named for the experiment (such as [[./uboone/]]).

* Configuration from a developer point of view

TBD.

* Configuration tests

FIXME: need to revisit this section.

Running the configuration tests is done through the files under =test/=.  They rely on a simple ad-hoc test harness. All tests can be run from the top-level =wire-cell= source directory after a build like:

#+BEGIN_EXAMPLE
  ./cfg/test/test_all.sh
#+END_EXAMPLE

A single test can be run like:

#+BEGIN_EXAMPLE
  ./cfg/test/test_one.sh <testname>
#+END_EXAMPLE

Each test has a =test_<testname>.jsonnet= file.

#+BEGIN_EXAMPLE
  ls cfg/test/test_*.jsonnet
#+END_EXAMPLE

These main JSonnet files are typically composed of some chunks reused by the various different tests. The chunks are named like =cfg_*.jsonnet=.  The body of each main =test_<testname>.jsonnet= largely consists of the data flow graph definition for the =TbbFlow= Wire Cell application object.
